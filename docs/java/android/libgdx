//УСТАНОВКА LIBGDX
//Зависимости для libgdx
JDK
Android Studio + Android SDK //http://developer.android.com/sdk/installing/index.html
Android virtual device

//libgdx
https://libgdx.badlogicgames.com/download.html -> Down load Setup App -> gdx-setup.jar
sudo chmod a+x gdx-setup.jar

//Установка проекта игры "test" на libgdx
Name: test (имя проекта)
Package: ru.test (имя пакета - адрес наоборот)
Game class: MyGame (Класс игры)
Destination: /path/to/my/game (Где будет храниться проект)
Android SDK: Путь к Android SDK
LibGDX Version: Release 1.7.0
Sub Projects: Desktop, Android
Extensions: none
GENERATE -> yes

//Путь к андроид sdk
Android studio -> configure -> project defaults -> project structure -> Android SDK location

//Запуск
Android Studio -> Import project (Eclipse ADT, Gradle, etc.) -> /path/to/my/game/build.gradle

//Модули проекта
android
    java
        package
            AndroidLauncher
                Класс, отвечающий за запуск игры в эмуляторе (Запуск отсюда)
                Инициирует класс MyGame из папки core
    assets
        Картинки и прочие графические ресурсы
core
    java
        package
            MyGame

desktop
    java
        package
            DesktopLauncher
                Запускалка десктопной версии игры

//Настройка модуля desktop для запуска не через эмулятор и более быстрой разработки
Верхнее меню android -> Edit Configuration -> + (Добавить конфигурацию) -> Application
Name: Desktop
Main class: DesktopLauncher
Working directiry: android/.../assets
Use classpath of module: desktop
OK

//Эмуляторы для андроид
GENYMOTION (4 версии)

//Установка genymotion (зависимость - virtualbox)
1. Регистрация на сайте genymotion.com
2. Скачивание эмулятора genymotion  https://www.genymotion.com/#!/download
3. Установка genymotion
    sudo chmod a+x genymotion-2.6.0-linux_x64.bin
    ./genymotion-2.6.0-linux_x64.bin
4. Установка плагина для android studio
    http://plugins.genymotion.com/plugins/idea/1.0.3/genymotion-idea-plugin-20140326.jar
5. Установка плагина в andriod studio
    Кнопка genymotion device manager -> указать путь к установленному genymotion

//Интерфейсы
Application (Gdx.app)
    запускает приложение и сообщает api-клиенту о событиях уровня приложения,
    таких как изменение размеров окна например, обеспечивает возможность логгирования
    и запросов например использования памяти
Files (Gdx.files)
    предоставляет лежащую в основе платформы файловую систему
Input
    информирует api-клиента о пользовательском вводе: о событиях мыши,
    клавиатуры, сенсора, аккселерометра (опрос и обработка событий)
Audio (Gdx.audio)
    предоставляет средство для воспроизведения звуковых эффектов и потоковой музыки,
    а так же прямой доступ к аудиоустройству для pcm-аудиоввода/вывода
Graphics
    предоставляет openGL и позволяет запрашивать и устанавливать видеорежимы

Описанные модули могут быть доступны через статические поля класса Gdx:
AudioDevice audioDevice = Gdx.audio.newAudioDevice(44100, false);

Для каждой платформы есть свой стартер-класс (AndroidLauncher, DesktopLauncher, ...)

//Методы ApplicationAdapter
public void create
    вызывается 1 раз при создании приложения
public void render
    вызывается каждым игровым циклом приложения кождый раз
    когда должна быть выполнена визуализация,
    обновление логики игры обычно выполняется в этом методе
public void resize
    вызывается при каждом изменении размеров экрана в игре
    и когда игра не находится в состоянии пауза
public void pause
    на андроид вызывается когда нажата кнопка home или при входящем звонке,
    на десктопе вызывает перед методом dispose при выходе из приложения.
    хорошее место для сохранения состаяния.
public void resume
    вызывается только на андроид когда приложение возобновляет работу
public void dispose
    вызывается когда приложение уничтожается, ему предшествует pause

Метод render можно считать телом главного цикла

Создание игры "Ловля капель"
Настройка стартер-классов
    Разрешение 800х480
        Модуль desktop desktop->DesktopLauncher::main
            config.title = "Drop";
            config.width = 800;
            config.height = 480;
        Модуль Html html->HtmlLauncher
            public GwtApplicationConfiguration getConfig(){
                return new GwtApplicationConfiguration(800, 480);
            }
        В модуле android разрешение устанавливается самой OS

    Ориентация экрана
        android->mainfests->AndroidMainfest.xml
            activity android:screenOrientation="landscape" //portrate

    Отключение акселерометра и компаса
        android->AndroidLauncher::onCreate
            config.useAccelerometer = false;
            config.useCompass = false;

Аспекты работы игры
    public void create()
        Инициализация и определение ресурсов
        Создание камеры
        Создание объекта SpriteBatch для отрисовки графический элементов
        Старт музыки
        Создание объектов Rectangle для каждого графического элемента для хранения размеров и координат
    public void render ()
        Очистка и заливка экрана
        Обновленмие камеры
        Отрисовка всех графических элементов (SpriteBatch)
        Обработка событий пользователя
        Обработка ухода элементов за границы экрана
        Реализация движения элементов - смена координат
    public void dispose()
        Освобождение ресурсов

Контрольные элементы игры
    Интерфейс класса        - gdx.ApplicationAdapter
    Камера                  - gdx.graphics.OrthographicCamera
    Отрисовка               - gdx.graphics.g2d.SpriteBatch
    Графика                 - gdx.graphics.Texture
    Звук                    - gdx.audio.Sound
    Музыка                  - gdx.audio.Music
    Размер/координаты       - gdx.math.Rectangle
    Вектор преобр координат - gdx.math.Vector3
    Массив                  - gdx.utils.Array
    Наносекунды             - gdx.utils.TimeUtils;
    Итератор массива        - java.util.Iterator
    Коды кнопок клавы       - gdx.Input

//Код класса Drop
package com.mygdx.game;

import com.badlogic.gdx.ApplicationAdapter;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.audio.Music;
import com.badlogic.gdx.audio.Sound;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.TimeUtils;
import com.badlogic.gdx.math.Rectangle;
import java.util.Iterator;

public class Drop extends ApplicationAdapter {

	OrthographicCamera camera;      //Камера
	SpriteBatch batch;              //Спрайт батч
	Texture dropImage;              //Картинка капли
	Texture bucketImage;            //Картинка ведра
	Sound dropSound;                //Звуковой эффект капли
	Music rainMusic;                //Музыка дождь
	Rectangle bucket;               //Сохранение положения и размера капли
	Vector3 touchPos;               //3х-мерный вектор
	Array<Rectangle> raindrops;     //Массив капель-экземпляров Rectangle для хранения позиции и размера капли
	long lastDropTime;              //Время последнего появления капли в наносекундах

	@Override
	public void create () {

		//Создаем камеру
		camera = new OrthographicCamera();
		//камера всегда показывает область мира игры размером 800х480 (вирт. окно в наш мир)
		camera.setToOrtho(false, 800, 480);

		batch = new SpriteBatch();

		touchPos = new Vector3();

		//Создаем объекты картинок
		dropImage = new Texture("droplet.png");
		bucketImage = new Texture("bucket.png");

		//Создаем объекты звука и музыки
		dropSound = Gdx.audio.newSound(Gdx.files.internal("waterdrop.wav"));
		rainMusic = Gdx.audio.newMusic(Gdx.files.internal("undertreeinrain.mp3"));

		//Указываем что музыка должна повторяться и влючаем ее
		rainMusic.setLooping(true);
		rainMusic.play();

		//Создаем ведро для капель
		bucket = new Rectangle();
		bucket.x = 800 / 2 - 64 / 2;
		bucket.y = 20;
		bucket.width = 64;
		bucket.height = 64;

		//Создаем массив капель (Rectangle) и первую каплю
		raindrops = new Array<Rectangle>();
		spawnRaindrop();
	}

	//Пишем метод для создания капли:
	private void spawnRaindrop(){
		//создание rectangle
		Rectangle raindrop = new Rectangle();
		//установка в случайную позицию наверху экрана
		raindrop.x = MathUtils.random(0, 800-64);
		raindrop.y = 480;
		raindrop.width = 64;
		raindrop.height = 64;
		//добавление объекта rectangle в массив raindrops
		raindrops.add(raindrop);
		lastDropTime = TimeUtils.nanoTime();
	}

	@Override
	public void render () {

		//Очищаем экран и заливаем синим
		Gdx.gl.glClearColor(0, 0, 0.2f, 1);
		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

		//Обновление камеры 1 раз в кадр
		camera.update();

		//Используем систему координат камеры
		batch.setProjectionMatrix(camera.combined);
		//Начинаем новую batch-серию
		batch.begin();
		batch.draw(bucketImage, bucket.x, bucket.y);
		//Добавляем отображение капель
		for (Rectangle raindrop: raindrops){
			batch.draw(dropImage, raindrop.x, raindrop.y);
		}
		batch.end();

		//По нажатию на сенсор или клику мыши, меняем позицию ведра
		if(Gdx.input.isTouched()){
			//Получение координат
			touchPos.set(Gdx.input.getX(), Gdx.input.getY(), 0);
			//Преобразования координат прикосновения в систему координат камеры
			camera.unproject(touchPos);
			//Изменяем позицию ведра
			bucket.x = (int) (touchPos.x -64 / 2);
		}

		//Перемещаем ведро на 200px по нажатию на стрелки клавиатуры за один кадр
		//getDeltaTime возвращает время прошедшее между последним и текущим кадром в секундах
		if(Gdx.input.isKeyPressed(Input.Keys.LEFT)) bucket.x -= 200 * Gdx.graphics.getDeltaTime();
		if(Gdx.input.isKeyPressed(Input.Keys.RIGHT)) bucket.x += 200 * Gdx.graphics.getDeltaTime();

		//Если ведро выходит на границу экрана, возвращаем
		if (bucket.x < 0) bucket.x = 0;
		if (bucket.x > 800 - 64) bucket.x = 800 - 64;

		//Если с тех пор как была создана последняя капля прошло больше 1000000000 нс,
		//необходимо создавать еще одну каплю
		if (TimeUtils.nanoTime() - lastDropTime > 1000000000) spawnRaindrop();

		//Реализуем движение каплей с постоянной скоростью 200px в секунду
		Iterator<Rectangle> iter = raindrops.iterator();
		while (iter.hasNext()){
			Rectangle raindrop = iter.next();
			raindrop.y -= 200 * Gdx.graphics.getDeltaTime();
			if (raindrop.y + 64 < 0) iter.remove();
			if (raindrop.overlaps(bucket)){
				dropSound.play();
				iter.remove();
			}
		}
	}

	//Освобождаем текстуры, звуи, музыку и spriteBatch
	@Override
	public void dispose() {
		super.dispose();
		dropImage.dispose();
		bucketImage.dispose();
		dropSound.dispose();
		rainMusic.dispose();
		batch.dispose();
	}
}
