//УСТАНОВКА LIBGDX
//Зависимости для libgdx
JDK
Android Studio + Android SDK //http://developer.android.com/sdk/installing/index.html
Android virtual device

//libgdx
https://libgdx.badlogicgames.com/download.html -> Down load Setup App -> gdx-setup.jar
sudo chmod a+x gdx-setup.jar

//Установка проекта игры "test" на libgdx
Name: test (имя проекта)
Package: ru.test (имя пакета - адрес наоборот)
Game class: MyGame (Класс игры)
Destination: /path/to/my/game (Где будет храниться проект)
Android SDK: Путь к Android SDK
LibGDX Version: Release 1.7.0
Sub Projects: Desktop, Android
Extensions: none
GENERATE -> yes

//Путь к андроид sdk
Android studio -> configure -> project defaults -> project structure -> Android SDK location

//Запуск
Android Studio -> Import project (Eclipse ADT, Gradle, etc.) -> /path/to/my/game/build.gradle

//Модули проекта
android
    java
        package
            AndroidLauncher
                Класс, отвечающий за запуск игры в эмуляторе (Запуск отсюда)
                Инициирует класс MyGame из папки core
    assets
        Картинки и прочие графические ресурсы
core
    java
        package
            MyGame

desktop
    java
        package
            DesktopLauncher
                Запускалка десктопной версии игры

//Настройка модуля desktop для запуска не через эмулятор и более быстрой разработки
Верхнее меню android -> Edit Configuration -> + (Добавить конфигурацию) -> Application
Name: Desktop
Main class: DesktopLauncher
Working directiry: android/.../assets
Use classpath of module: desktop
OK

//Эмуляторы для андроид
GENYMOTION (4 версии)

//Установка genymotion (зависимость - virtualbox)
1. Регистрация на сайте genymotion.com
2. Скачивание эмулятора genymotion  https://www.genymotion.com/#!/download
3. Установка genymotion
    sudo chmod a+x genymotion-2.6.0-linux_x64.bin
    ./genymotion-2.6.0-linux_x64.bin
4. Установка плагина для android studio
    http://plugins.genymotion.com/plugins/idea/1.0.3/genymotion-idea-plugin-20140326.jar
5. Установка плагина в andriod studio
    Кнопка genymotion device manager -> указать путь к установленному genymotion

//Интерфейсы
Application (Gdx.app)
    запускает приложение и сообщает api-клиенту о событиях уровня приложения,
    таких как изменение размеров окна например, обеспечивает возможность логгирования
    и запросов например использования памяти
Files (Gdx.files)
    предоставляет лежащую в основе платформы файловую систему
Input
    информирует api-клиента о пользовательском вводе: о событиях мыши,
    клавиатуры, сенсора, аккселерометра (опрос и обработка событий)
Audio (Gdx.audio)
    предоставляет средство для воспроизведения звуковых эффектов и потоковой музыки,
    а так же прямой доступ к аудиоустройству для pcm-аудиоввода/вывода
Graphics
    предоставляет openGL и позволяет запрашивать и устанавливать видеорежимы

Описанные модули могут быть доступны через статические поля класса Gdx:
AudioDevice audioDevice = Gdx.audio.newAudioDevice(44100, false);

Для каждой платформы есть свой стартер-класс (AndroidLauncher, DesktopLauncher, ...)

//Методы ApplicationAdapter
public void create
    вызывается 1 раз при создании приложения
public void render
    вызывается каждым игровым циклом приложения кождый раз
    когда должна быть выполнена визуализация,
    обновление логики игры обычно выполняется в этом методе
public void resize
    вызывается при каждом изменении размеров экрана в игре
    и когда игра не находится в состоянии пауза
public void pause
    на андроид вызывается когда нажата кнопка home или при входящем звонке,
    на десктопе вызывает перед методом dispose при выходе из приложения.
    хорошее место для сохранения состаяния.
public void resume
    вызывается только на андроид когда приложение возобновляет работу
public void dispose
    вызывается когда приложение уничтожается, ему предшествует pause

Метод render можно считать телом главного цикла

Создание игры "Ловля капель"
Настройка стартер-классов
    Разрешение 800х480
        Модуль desktop desktop->DesktopLauncher::main
            config.title = "Drop";
            config.width = 800;
            config.height = 480;
        Модуль Html html->HtmlLauncher
            public GwtApplicationConfiguration getConfig(){
                return new GwtApplicationConfiguration(800, 480);
            }
        В модуле android разрешение устанавливается самой OS

    Ориентация экрана
        android->mainfests->AndroidMainfest.xml
            activity android:screenOrientation="landscape" //portrait

    Отключение акселерометра и компаса
        android->AndroidLauncher::onCreate
            config.useAccelerometer = false;
            config.useCompass = false;

Аспекты работы игры
    public void create()
        Инициализация и определение ресурсов
        Создание камеры
        Создание объекта SpriteBatch для отрисовки графический элементов
        Старт музыки
        Создание объектов Rectangle для каждого графического элемента для хранения размеров и координат
    public void render ()
        Очистка и заливка экрана
        Обновленмие камеры
        Отрисовка всех графических элементов (SpriteBatch)
        Обработка событий пользователя
        Обработка ухода элементов за границы экрана
        Реализация движения элементов - смена координат
    public void dispose()
        Освобождение ресурсов

Контрольные элементы игры
    Интерфейс класса        - gdx.ApplicationAdapter
    Камера                  - gdx.graphics.OrthographicCamera
    Отрисовка               - gdx.graphics.g2d.SpriteBatch
    Графика                 - gdx.graphics.Texture
    Звук                    - gdx.audio.Sound
    Музыка                  - gdx.audio.Music
    Размер/координаты       - gdx.math.Rectangle
    Вектор преобр координат - gdx.math.Vector3
    Массив                  - gdx.utils.Array
    Наносекунды             - gdx.utils.TimeUtils;
    Итератор массива        - java.util.Iterator
    Коды кнопок клавы       - gdx.Input

//Код класса Drop
package com.mygdx.game;

import com.badlogic.gdx.ApplicationAdapter;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.audio.Music;
import com.badlogic.gdx.audio.Sound;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.TimeUtils;
import com.badlogic.gdx.math.Rectangle;
import java.util.Iterator;

public class Drop extends ApplicationAdapter {

	OrthographicCamera camera;      //Камера
	SpriteBatch batch;              //Спрайт батч
	Texture dropImage;              //Картинка капли
	Texture bucketImage;            //Картинка ведра
	Sound dropSound;                //Звуковой эффект капли
	Music rainMusic;                //Музыка дождь
	Rectangle bucket;               //Сохранение положения и размера капли
	Vector3 touchPos;               //3х-мерный вектор
	Array<Rectangle> raindrops;     //Массив капель-экземпляров Rectangle для хранения позиции и размера капли
	long lastDropTime;              //Время последнего появления капли в наносекундах

	@Override
	public void create () {

		//Создаем камеру
		camera = new OrthographicCamera();
		//камера всегда показывает область мира игры размером 800х480 (вирт. окно в наш мир)
		camera.setToOrtho(false, 800, 480);

		batch = new SpriteBatch();

		touchPos = new Vector3();

		//Создаем объекты картинок
		dropImage = new Texture("droplet.png");
		bucketImage = new Texture("bucket.png");

		//Создаем объекты звука и музыки
		dropSound = Gdx.audio.newSound(Gdx.files.internal("waterdrop.wav"));
		rainMusic = Gdx.audio.newMusic(Gdx.files.internal("undertreeinrain.mp3"));

		//Указываем что музыка должна повторяться и влючаем ее
		rainMusic.setLooping(true);
		rainMusic.play();

		//Создаем ведро для капель
		bucket = new Rectangle();
		bucket.x = 800 / 2 - 64 / 2;
		bucket.y = 20;
		bucket.width = 64;
		bucket.height = 64;

		//Создаем массив капель (Rectangle) и первую каплю
		raindrops = new Array<Rectangle>();
		spawnRaindrop();
	}

	//Пишем метод для создания капли:
	private void spawnRaindrop(){
		//создание rectangle
		Rectangle raindrop = new Rectangle();
		//установка в случайную позицию наверху экрана
		raindrop.x = MathUtils.random(0, 800-64);
		raindrop.y = 480;
		raindrop.width = 64;
		raindrop.height = 64;
		//добавление объекта rectangle в массив raindrops
		raindrops.add(raindrop);
		lastDropTime = TimeUtils.nanoTime();
	}

	@Override
	public void render () {

		//Очищаем экран и заливаем синим
		Gdx.gl.glClearColor(0, 0, 0.2f, 1);
		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

		//Обновление камеры 1 раз в кадр
		camera.update();

		//Используем систему координат камеры
		batch.setProjectionMatrix(camera.combined);
		//Начинаем новую batch-серию
		batch.begin();
		batch.draw(bucketImage, bucket.x, bucket.y);
		//Добавляем отображение капель
		for (Rectangle raindrop: raindrops){
			batch.draw(dropImage, raindrop.x, raindrop.y);
		}
		batch.end();

		//По нажатию на сенсор или клику мыши, меняем позицию ведра
		if(Gdx.input.isTouched()){
			//Получение координат
			touchPos.set(Gdx.input.getX(), Gdx.input.getY(), 0);
			//Преобразования координат прикосновения в систему координат камеры
			camera.unproject(touchPos);
			//Изменяем позицию ведра
			bucket.x = (int) (touchPos.x -64 / 2);
		}

		//Перемещаем ведро на 200px по нажатию на стрелки клавиатуры за один кадр
		//getDeltaTime возвращает время прошедшее между последним и текущим кадром в секундах
		if(Gdx.input.isKeyPressed(Input.Keys.LEFT)) bucket.x -= 200 * Gdx.graphics.getDeltaTime();
		if(Gdx.input.isKeyPressed(Input.Keys.RIGHT)) bucket.x += 200 * Gdx.graphics.getDeltaTime();

		//Если ведро выходит на границу экрана, возвращаем
		if (bucket.x < 0) bucket.x = 0;
		if (bucket.x > 800 - 64) bucket.x = 800 - 64;

		//Если с тех пор как была создана последняя капля прошло больше 1000000000 нс,
		//необходимо создавать еще одну каплю
		if (TimeUtils.nanoTime() - lastDropTime > 1000000000) spawnRaindrop();

		//Реализуем движение каплей с постоянной скоростью 200px в секунду
		Iterator<Rectangle> iter = raindrops.iterator();
		while (iter.hasNext()){
			Rectangle raindrop = iter.next();
			raindrop.y -= 200 * Gdx.graphics.getDeltaTime();
			if (raindrop.y + 64 < 0) iter.remove();
			if (raindrop.overlaps(bucket)){
				dropSound.play();
				iter.remove();
			}
		}
	}

	//Освобождаем текстуры, звуи, музыку и spriteBatch
	@Override
	public void dispose() {
		super.dispose();
		dropImage.dispose();
		bucketImage.dispose();
		dropSound.dispose();
		rainMusic.dispose();
		batch.dispose();
	}
}

//Переключения между экранами
//Точка входа - Drop.java
public class Drop extends Game{
    public void create() {
	//Точка входа, включение экрана с меню
        this.setScreen(new MainMenuScreen(this));
    }
}

//Экран с меню игры - MainMenuScreen.java
public class MainMenuScreen implements Screen{

    //Инстанс Game, нужно для переключения экрана
    final Drop game;

    //Инстанс камеры и т.д.
    OrthographicCamera camera;

    public MainMenuScreen(final Drop gam){
        game = gam;
        //Инициализация камеры
    }

    public void render(float delta) {
	//Обработка ввода пользователя
        if (Gdx.input.isTouched()){
            //Переключение экрана на экран игры
            game.setScreen(new GameScreen(game));
        }
    }

    //Событие при активизации экрана
    public void show(){}

    //Событие при деактивизации экрана
    public void hide(){}
}


//Экран с игрой - GameScreen.java
public class GameScreen implements Screen{

    final Drop game;

    public GameScreen (final Drop gam){
        this.game = gam;
        //Инициализация камеры и т.д.
    }

    //Отрисовка
    public void render (float delta){}

    //Событие при активизации экрана
    public void show(){}

    //Событие при деактивизации экрана
    public void hide(){}
}

//Полезное
Импорт класса: клик + ALT + ENTER
Документация: https://libgdx.badlogicgames.com/nightlies/docs/api/
Размеры окна: Gdx.graphics.getWidth(), Gdx.graphics.getHeight()
Время в сек. от последнего render'а: Gdx.graphics.getDeltaTime()


//SpriteBatch (0, 0 - левый нижний угол)
//Методы для рисования текстуры
batch.draw(texture, x, y);
batch.draw(texture, x, y, width, height);
batch.draw(texture, x, y, textureX, textureY, width, height);
batch.draw(texture, x, y, width, height, textureX, textureY, textureWidth, textureHeight, mirrorX, mirrorY);
batch.draw(texture, x, y, centerX, centerY, width, height, scaleX, scaleY, rotation, textureX, textureY, textureWidth, textureHeight, mirrorX, mirrorY);
//Чтобы вращать вокруг центра: centerX = width/2; centerY = height/2;

//Методы для рисования региона текстуры
batch.draw(textureRegion, x, y, width, height);
batch.draw(textureRegion, x, y, centerX, centerY, width, height, scaleX, scaleY, rotation);

//Texture
SpriteBatch batch = new SpriteBatch();
Texture texture = new Texture("badlogic.jpg");

batch.begin();
batch.draw(texture, 100, 100);
batch.end();

//TextureRegion (0, 0 - левый верхний угол)
SpriteBatch batch = new SpriteBatch();
Texture texture = new Texture("badlogic.jpg");
TextureRegion textureRegion = new TextureRegion(texture, 0, 0, width, height);

batch.begin();
batch.draw(textureRegion, x+200, y+200);
batch.end();

//Sprite
SpriteBatch batch = new SpriteBatch();
Texture texture = new Texture("badlogic.jpg");
Sprite sprite = new Sprite(texture, 0, 0, 256, 256);
sprite.setPosition(100, 100);
sprite.setRotation(90);

batch.begin();
sprite.draw(batch);
batch.end();

//Tinting - наложение цветного фильтра (red (0..1), green (0..1), blue (0..1), a (0..1))
SpriteBatch batch = new SpriteBatch();
Texture texture = new Texture("badlogic.jpg");

batch.begin();
batch.setColor(1, 0, 0, 1);
batch.draw(texture, 0, 0);
batch.end();

//Stage и Actor - сцена и актеры
class Quad extends Actor {

	@Override
	public void draw(Batch batch, float parentAlpha){
		Texture texture = new Texture("badlogic.jpg");
		batch.draw(texture, getX(), getY(), getWidth(), getHeight());
	}
}

//render
Quad actor = new Quad();

Stage stage = new Stage(new ScreenViewport());
Gdx.input.setInputProcessor(stage);

actor.setSize(100, 100);
actorsetPosition(0, 0);
//actor.setOrigin()
//actor.setRotation()
//actor.setX(), actor.setY()
//actor.setWidth(), actor.setHeight()

stage.addActor(actor);

stage.draw();
stage.act(Gdx.graphics.getDeltaTime());

stage.draw(); //Вызов методов draw у каждого актера
stage.act(Gdx.graphics.getDeltaTime()); //Вызов методов act у каждого актера

//Group - группа актеров
//Group наследует Actor => все его методы
Quad actor1 = new Quad();
actor1.setSize(100, 100);
actor1.setPosition(0, 0);

Quad actor2 = new Quad();
actor2.setSize(100, 100);
actor2.setPosition(100, 0);

Group group = new Group();
group.setSize(200, 200);
group.setPosition(0, 0);
group.addActor(actor1);
group.addActor(actor2);
//group.addActorAt(zIndex, actor);
//group.removeActorAt(actor);
//group.getActors();

Stage stage = new Stage(new ScreenViewport());
Gdx.input.setInputProcessor(stage);
stage.addActor(group);
stage.draw();
stage.act(Gdx.graphics.getDeltaTime());

//Интерфейс Screen
render(float delta)
resize(width, height)
show() //Экран становится текущим
hide()
pause()
resume()
dispose()

//Game - Управление экранами Screen (implements ApplicationListener)
setScreen(Screen screen) hide, screen=src, show, resize(Gdx.graphics.getWidth(), Gdx.graphics.getHeight())
getScreen() //return screen
dispose() //screen.hide()
pause() //screen.pause()
resume() //screen.resume()
render(float delta) //screen.render(Gdx.graphics.getDeltaTime())
resize(width, height)  //screen.resize(width, height)

class MyScreen implements Screen {

    Texture texture;
    SpriteBatch batch;

    public MyScreen(SpriteBatch btc){

        texture = new Texture("badlogic.jpg");
        batch = btc;
    }

    @Override
    public void render(float delta) {

        Gdx.gl.glClearColor(1, 0, 0, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        batch.begin();
        batch.draw(texture, 0, 0);
        batch.end();
    }

    @Override
    public void show() {}

    @Override
    public void resize(int width, int height) {}

    @Override
    public void pause() {}

    @Override
    public void resume() {}

    @Override
    public void hide() {}

    @Override
    public void dispose() {}
}

public class MyGdxGame extends Game {

	Screen myScreen;
	SpriteBatch batch;

	@Override
	public void create () {

		batch = new SpriteBatch();
		myScreen = new MyScreen(batch);
		setScreen(myScreen);
	}
}

//Обработка событий (polling, events)
//Определение собственного обработчика ввода (polling)
//Application::create()
Gdx.input.setInputProcessor(new MyInputListener());

//MyInputListener.java
public class MyInputListener implements InputProcessor{

    @Override
    public boolean keyDown(int keycode) {

        switch(keycode){
            case Input.Keys.UP:
                System.out.println("UP");
                break;
            case Input.Keys.DOWN:
                System.out.println("DOWN");
                break;
            case Input.Keys.LEFT:
                System.out.println("LEFT");
                break;
            case Input.Keys.RIGHT:
                System.out.println("RIGHT");
                break;
        }

        return false;
    }

    @Override
    public boolean keyUp(int keycode) {
        return false;
    }

    @Override
    public boolean keyTyped(char character) {
        return false;
    }

    @Override
    public boolean touchDown(int screenX, int screenY, int pointer, int button) {
        System.out.println("touchDown");
        return false;
    }

    @Override
    public boolean touchUp(int screenX, int screenY, int pointer, int button) {
        return false;
    }

    @Override
    public boolean touchDragged(int screenX, int screenY, int pointer) {
        return false;
    }

    @Override
    public boolean mouseMoved(int screenX, int screenY) {
        return false;
    }

    @Override
    public boolean scrolled(int amount) {
        return false;
    }
}

//Событийная модель
//Листнер актера
public class MyActorListener extends InputListener {

    @Override
    public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
        System.out.println("touchDown");
        return true;
    }

    @Override
    public boolean keyDown(InputEvent event, int keycode) {

        float x = event.getListenerActor().getX();
        float y = event.getListenerActor().getY();

        switch(keycode){
            case Input.Keys.UP:
                System.out.println("UP");
                break;
            case Input.Keys.DOWN:
                System.out.println("DOWN");
                break;
            case Input.Keys.LEFT:
                System.out.println("LEFT");
                break;
            case Input.Keys.RIGHT:
                System.out.println("RIGHT");
                break;
        }

        return false;
    }
}

//Актер
public class MyActorListener extends InputListener {

    @Override
    public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
        System.out.println("touchDown");
        return true;
    }

    @Override
    public boolean keyDown(InputEvent event, int keycode) {

        float x = event.getListenerActor().getX();
        float y = event.getListenerActor().getY();

        switch(keycode){
            case Input.Keys.UP:
                System.out.println("UP");
                break;
            case Input.Keys.DOWN:
                System.out.println("DOWN");
                break;
            case Input.Keys.LEFT:
                System.out.println("LEFT");
                break;
            case Input.Keys.RIGHT:
                System.out.println("RIGHT");
                break;
        }

        return false;
    }
}

//Запуск
public class MyActorListener extends InputListener {

    @Override
    public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
        System.out.println("touchDown");
        return true;
    }

    @Override
    public boolean keyDown(InputEvent event, int keycode) {

        float x = event.getListenerActor().getX();
        float y = event.getListenerActor().getY();

        switch(keycode){
            case Input.Keys.UP:
                System.out.println("UP");
                break;
            case Input.Keys.DOWN:
                System.out.println("DOWN");
                break;
            case Input.Keys.LEFT:
                System.out.println("LEFT");
                break;
            case Input.Keys.RIGHT:
                System.out.println("RIGHT");
                break;
        }

        return false;
    }
}

//Дизайн игры
 - Жанр
 - Режимы игры: 1 игрок, 2 игрока
 - Количество экранов
 - Ресурсы: картинки, звуки, шрифты
 - Актеры, Сцены, Экраны, Обработчики
