//В V8 большинство возможностей ES-2015 поддерживаются только при включённом use strict
'use strict';

//Проверка поддержки es6
https://kangax.github.io/compat-table/es6/

//let - объявление локальной переменной внутри блока
//Переменная видна только после объявления и только в текущем блоке
//Нельзя переобъявлять в том же блоке
if (true) let apples = 10;

//const - объявление константы, которую нельзя менять, в остальном как let
const apple = 5;

//Деструктуризация
let [first, last] = ["1", "2"];
let [,,title] = "1 2 3 4".split(" "); //title = 3
let [first="1", last] = []; //first = 1, last = undefined
let {title, title: t, width:w=100} = {title: "1"}; //title=t="1", w=100
let {...all} = {title: "1"}; //all = {title: "1"}
let {title, size: {width, height}, items: [item1, item2]} = options; //Вложенная деструктуризация

//ОШИБКА
let a, b;
{a, b} = {a:5, b:6};

//НЕТ ОШИБКИ
let a, b;
({a, b} = {a:5, b:6});

//Оператор «spread»
let [first, last, ...rest] = "1 2 3 4".split(" ");
//rest = ["3", "4"]
function foo(first, last, ...rest) {} //Оператор … должен быть в конце

//Параметры по умолчанию
function foo(title = "1"){
    alert(`${title}`);
}
function foo(title = 1+2){}

//Передача массива как списка
let max = Math.max(...numbers);

//Деструктуризация в параметрах
let options = {title: "Меню"};
function foo({title="1", width:w=100, height:h=200}) {}
foo(options);

//Имя функции «name»
function f() {} // f.name == "f"

//Объявление функции Function Declaration, сделанное в блоке, видно только в этом блоке
if (true) {
    sayHi(); // работает

    function sayHi() {
        alert("Привет!");
    }
}

//Функции-стрелки =>
let inc = x => x+1;      //let inc = function(x) { return x + 1; };
let sum = (a,b) => a + b;//let sum = function(a,b){ return a + b; };
let getTrue = () => true;//let getTrue = function(){ return true; };
let getTime = () => {
    let date = new Date();
    let hours = date.getHours();
    let minutes = date.getMinutes();
    return `${hours}:${minutes}`;
};
alert(getTime());
//Функции-стрелки не имеют своего this - внутри – тот же this, что и снаружи.
//Функции-стрелки не имеют своего arguments
//Функции-стрелки не могут быть использованы как конструкторы, с new.

//Новый вид кавычек для строк (разрешён перевод строки)
let str = `обратные
    кавычки`;

//Полезные методы
str.includes(s) – проверяет, включает ли одна строка в себя другую, возвращает true/false.
str.endsWith(s) – возвращает true, если строка str заканчивается подстрокой s.
str.startsWith(s) – возвращает true, если строка str начинается со строки s.
str.repeat(times) – повторяет строку str times раз.

//ОБЪЕКТЫ
//Авторасстановка имени свойств для объекта
let name = 'ivan';
let user = {name}; //{name: 'Ivan'}

//Выражение в качестве имени свойства или метода объекта
let name = 'params';
let user = {
    [name]: [],     //params: []
    [('p'+'r')]: '' //pr: ''
};

//Геттер-сеттер для прототипа
Object.setPrototypeOf(obj, newProto)

//Узаконено свойство __proto__, которое даёт прямой доступ к прототипу

//Слияние объектов
let o1 = {name: 'name'};
let o2 = {title: 'title'};
Object.assign(o1, o2); //o1 = {name: 'name', title: 'title'}
let clone = Object.assign({}, o2); //{title: 'title'}

//Короткое описание метода объекта
let o = {
    foo(){} //o.foo();
};

//Ключевое слово super для вызова метода родителя
let rabbit = {
    __proto__: animal,
    walk(){
        super.walk();
    }
};

//КЛАССЫ
//Ключевое слово class
class User{
    constructor(name){}
    doSmth(){}
}

let obj = new User('Name');
obj.doSmth();

//Дополнительно
1. constructor запускается при создании new User, остальные методы записываются в User.prototype
2. User нельзя вызывать без new, будет ошибка.
3. Объявление класса с точки зрения области видимости ведёт себя как let
4. Метод doSmth является именно методом, то есть имеет доступ к super
5. Все методы класса работают в строгом режиме use strict, даже если он не указан
6. Все методы класса не перечислимы. То есть в цикле for..in по объекту их не будет

//Class Expression - присваивание класса переменной
let User = class{
  doSmth(){}
};
new User().doSmth();

let u = class User{
  doSmth(){}
};
new u().doSmth(); //Норм
new User(); //Ошибка

//Геттеры, сеттеры и вычисляемые свойства
class User{
    constructor(name){
        this.name = name;
    }

    get name(){
        return `$(this.name)`;
    }

    set name(newName){
       [this.name] = newName;
    }
}
let user = new User('Name');
user.name //вызов геттера
user.name = 'new Name' //вызов сеттера

//Нет возможности задать в прототипе обычное значение (не функцию), такое как User.prototype.name = "Name"

//Статические свойства
class User{
    static hello() {}
};
let user = User.hello();

//Статическая константа
class Menu{
    static get test() {
        return 'test'
    }
}
alert(Menu.test); //test

//Наследование
class Rabbit extends Animal{
    constructor(name){
        super(name);
    }

    test(){
        return super.test(name);
    }
}
new Rabbit("Name").test();

//Детали
1. Вызвать конструктор родителя можно только изнутри конструктора потомка. В частности, super() нельзя вызвать из произвольного метода.
2. В конструкторе потомка мы обязаны вызвать super() до обращения к this. До вызова super не существует this, так как по спецификации в этом случае именно super инициализует this.

