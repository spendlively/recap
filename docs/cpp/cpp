1. Заголовочные файлы, gcc
2. make
3. Библиотеки, LD
4. Отладка gdb
5. MySQL
6. Выделение памяти
7. Процессы и сигналы
8. Потоки
9. Каналы
10. Семафоры, совместная память
11. Сокеты
12. Дизассемблирование/ассемблирование
13. GTK+
14. Qt



///////////////////////////////////////////////////
///////////////1. Заголовочные файлы///////////////
///////////////////////////////////////////////////
//Чтобы использовать функцию из другого файла
//в исходный файл нужно поместить ее прототип
/* main.c */
#include <stdio.h>

int add(int a, int b);

int main(void)
{
	printf("%d\n", add(1,2));
	return 0;
}
// gcc -o test main.c add.c
// ./test


//Прототипы удобнее хранить в отдельных заголовочных файлах
//и подключать в файлы, где требуется прототип, одной строкой
/* main.c */
#include <stdio.h>
#include "add.h"

int main(void)
{
	printf("%d\n", add(1,2));
	return 0;
}
// gcc -o test main.c add.c
// ./test


//Для избежания дублирования в заголовочных файлах
//могут использоваться директивы макрозащиты препроцессора
/* add.h */
#ifndef ADD_H
#define ADD_H
 
int add(int, int);
 
#endif


///////////////////////////////////////////////////
////////////////////2. make////////////////////////
///////////////////////////////////////////////////
//Make файлы используются чтобы автоматизировать
//компиляцию сложной программы
/* Makefile */
myapp: main.o add.o
	gcc -o myapp main.o add.o

main.o: main.c
	gcc -c main.c add.h

add.o: add.c
	gcc -c add.c
	
// make
// make -f Makefile (с указанием make файла, по умолчанию makefile или Makefile)
//make -k (продолжать при ошибках)
//make -n (вывод перечня действий без их выполнения)

//Make файл состоит из целей
myapp, main.o, add.o

//завсимостей
main.o add.o

//и правил
gcc -o myapp main.o add.o

//Если удалить какой-то из файлов после сборки,
//при повторном запуске make создаст только этот файл


///////////////////////////////////////////////////
/////////////////3. Библиотеки, LD/////////////////
///////////////////////////////////////////////////

//СТАТИЧЕСКАЯ КОМПОНОВКА

//Компиляция с линковкой объектных и заголовочных файлов из произвольного каталога
gcc -I/path/to/headers file1.c /path/to/file2.o /path/to/file3.o -o test

//Чтобы не линковать несколько объектных файлов вручную, их можно объединить в статическую библиотеку.
//Статическая библиотека это архив lib<имя>.a с объектными файлами <имя>.o
//Статическая, значит, что отдельные части нельзя менять без пересборки всего проекта.

//Создание архива
ar -rcs libtest.a file1.o file2.o

//Просмотр архива
nm libtest.a
00000000 T __foo  (Т - функция foo())

//Компиляция архива из стандартного каталога (/usr/lib или /usr/local/lib)
gcc test.c -ltest -o test

//Компиляция архива из пользовательского каталога
gcc test.c -L /path/to/dir/ -ltest -o test

//Извлечение объектного файла из архива
ar -x libtest.a file1.o

//Компановщик (ld) создает связь м/у тем местом
//где функция была вызвана и тем местом, где она лежит

//ДИНАМИЧЕСКАЯ КОМПОНОВКА - единый кусок объектного кода

//Компиляция динамеческой библиотеки
gcc -I/includes -fPIC -c mylib.c -o mylib.o
//gcc -c mylib.c -o mylib.o (Если заголовки в стандартном каталоге)
gcc -shared mylib.o -o
cp mylib.so /libs
//sudo gcc -shared mylib.o -o /usr/local/lib/libmylib.so


-fPIC - (необязательно) для создания позиционно независимого кода (код можно перемещать в памяти)
-shared - конвертировать объектный файл в динамическую библиотеку

//Файл .so нельзя переименовывать после компиляции

//Компиляция программы
gcc -I/include -c main.c -o main.o
gcc main.o -L/libs -lmylib -o main

//Компилятор включит не код библиотеки в исполняемый файл,
//а код заполнитель, который будет искать библиотеку
//и выполнять компоновку во время работы приложения

//Компилятор включит только имя файла mylib.so
//Если файл хранится за пределами стандартных каталогов (/usr/lib или /usr/local/lib)
//линукс проверяет директории описанные в переменной LD_LIBRARY_PATH.
//Поэтому в линукс необходимо задать переменную LD_LIBRARY_PATH
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:libs

//Ядро линукс скомпоновано статически


