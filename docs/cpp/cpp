1. Заголовочные файлы, gcc
2. make
3. Библиотеки, LD
4. Отладка gdb
5. MySQL
6. Выделение памяти
7. Процессы и сигналы
8. Потоки
9. Каналы
10. Семафоры, совместная память
11. Сокеты
12. Дизассемблирование/ассемблирование
13. GTK+
14. Qt


///////////////////////////////////////////////////
///////////////1. Заголовочные файлы///////////////
///////////////////////////////////////////////////
//Чтобы использовать функцию из другого файла
//в исходный файл нужно поместить ее прототип
/* main.c */
#include <stdio.h>

int add(int a, int b);

int main(void)
{
	printf("%d\n", add(1,2));
	return 0;
}
// gcc -o test main.c add.c
// ./test


//Прототипы удобнее хранить в отдельных заголовочных файлах
//и подключать в файлы, где требуется прототип, одной строкой
/* main.c */
#include <stdio.h>
#include "add.h"

int main(void)
{
	printf("%d\n", add(1,2));
	return 0;
}
// gcc -o test main.c add.c
// ./test


//Для избежания дублирования в заголовочных файлах
//могут использоваться директивы макрозащиты препроцессора
/* add.h */
#ifndef ADD_H
#define ADD_H
 
int add(int, int);
 
#endif


//Стандартные каталоги для заголовочных файлов
/usr/include
/usr/local/include

//Поиск заголовка
locate locale.h

//Компиляция с указанием каталога с заголовочными файлами
gcc main.c -I/home/user/include

//Стандартные каталоги для файлов библиотек
/usr/lib
/usr/local/lib

///////////////////////////////////////////////////
////////////////////2. make////////////////////////
///////////////////////////////////////////////////
//Make файлы используются чтобы автоматизировать
//компиляцию сложной программы
/* Makefile */
myapp: main.o add.o
	gcc -o myapp main.o add.o

main.o: main.c
	gcc -c main.c add.h

add.o: add.c
	gcc -c add.c
	
// make
// make -f Makefile (с указанием make файла, по умолчанию makefile или Makefile)
//make -k (продолжать при ошибках)
//make -n (вывод перечня действий без их выполнения)

//Make файл состоит из целей
myapp, main.o, add.o

//завсимостей
main.o add.o

//и правил
gcc -o myapp main.o add.o

//Если удалить какой-то из файлов после сборки,
//при повторном запуске make создаст только этот файл


///////////////////////////////////////////////////
/////////////////3. Библиотеки, LD/////////////////
///////////////////////////////////////////////////

//СТАТИЧЕСКАЯ КОМПОНОВКА

//Компиляция с линковкой объектных и заголовочных файлов из произвольного каталога
gcc -I/path/to/headers file1.c /path/to/file2.o /path/to/file3.o -o test

//Чтобы не линковать несколько объектных файлов вручную, их можно объединить в статическую библиотеку.
//Статическая библиотека это архив lib<имя>.a с объектными файлами <имя>.o
//Статическая, значит, что отдельные части нельзя менять без пересборки всего проекта.

//Создание архива
ar -rcs libtest.a file1.o file2.o

//Просмотр архива
nm libtest.a
00000000 T __foo  (Т - функция foo())

//Компиляция архива из стандартного каталога (/usr/lib или /usr/local/lib)
gcc test.c -ltest -o test

//Компиляция архива из пользовательского каталога
gcc test.c -L /path/to/dir/ -ltest -o test

//Извлечение объектного файла из архива
ar -x libtest.a file1.o

//Компановщик (ld) создает связь м/у тем местом
//где функция была вызвана и тем местом, где она лежит

//ДИНАМИЧЕСКАЯ КОМПОНОВКА - единый кусок объектного кода

//Компиляция динамеческой библиотеки
gcc -I/includes -fPIC -c mylib.c -o mylib.o
//gcc -c mylib.c -o mylib.o (Если заголовки в стандартном каталоге)
gcc -shared mylib.o -o
cp mylib.so /libs
//sudo gcc -shared mylib.o -o /usr/local/lib/libmylib.so


-fPIC - (необязательно) для создания позиционно независимого кода (код можно перемещать в памяти)
-shared - конвертировать объектный файл в динамическую библиотеку

//Файл .so нельзя переименовывать после компиляции

//Компиляция программы
gcc -I/include -c main.c -o main.o
gcc main.o -L/libs -lmylib -o main

//Компилятор включит не код библиотеки в исполняемый файл,
//а код заполнитель, который будет искать библиотеку
//и выполнять компоновку во время работы приложения

//Компилятор включит только имя файла mylib.so
//Если файл хранится за пределами стандартных каталогов (/usr/lib или /usr/local/lib)
//линукс проверяет директории описанные в переменной LD_LIBRARY_PATH.
//Поэтому в линукс необходимо задать переменную LD_LIBRARY_PATH
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:libs

//Ядро линукс скомпоновано статически

//Просмотр зависимостей от динамических библиотек
ldd main
	libadd.so => not found
	or
	libadd.so => /usr/lib/libadd.so
//Больше информации
ldd -v main

//Настройка динамического связывания во время выполнения
ldconfig

//ПЕРМЕННЫЕ ОКРУЖЕНИЯ
//Задание переменной окружения перед запуском программы
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:libs
//Переменные окружения на уровне системы устанавливаются через файл /etc/environment:
ENVIRONMENT="dev"
//Установка переменной окружения для конкретного пользователя через файл ~/.bashrc или ~/.bash_profile:
PATH="${PATH}:/home/user/bin:"


///////////////////////////////////////////////////
/////////////////4. Отладка gdb////////////////////
///////////////////////////////////////////////////
gcc -g -o main main.c

//Запуск дебаггера
gdb main

//Поставить точку останова в main и запуск
(gdb) break main
(gdb) run

//Переход к следующей строке
(gdb) next

//Вывод содержимого переменной i
(gdb) print i
//Вывод адреса переменной i
(gdb) print &i
//Вывод размера переменной i
(gdb) print sizeof(i)
//Вывод размера переменной типа int
(gdb) print sizeof(int)
//Вывод размера типа переменной i, типа возвращаемого значения main
(gdb) ptype i
(gdb) ptype main

//Вывести 4 байта памяти начиная с адреса переменной i
(gdb) x/12xb &i


///////////////////////////////////////////////////
////////////////////5. MySQL///////////////////////
///////////////////////////////////////////////////
//Установка необходимых пакетов для заголовочный файлов и библиотек
apt-get install libmysqlclient-dev

//Компиляция программы с библиотекой mysqlclient
gcc -I/usr/include/mysql main.c -L/usr/lib/mysql -lmysqlclient -o main

#include <stdio.h>
#include <stdlib.h>
#include "mysql.h"

int main(){

	//Инициализация дескриптора
	MYSQL *connection;
	connection = mysql_init(NULL);
	if(!connection){
		fprintf(stderr, "mysql_init failed!\n");
		return EXIT_FAILURE;
	}

	//Подключение к субд
	connection = mysql_real_connect(connection, "localhost", "rick", "passme", "foo", 0, NULL, 0);
	if(connection){
		printf("Connection success!\n");
	}
	else{
		printf("Connection failed!\n");
	}

	int res;

	//Выполнение комманды
	res = mysql_query(connection, "INSERT INTO test (id, name) VALUES (NULL, 'Kostya');");
	if(res){
		fprintf(stderr, "Insert error %d: %s!\n", mysql_errno(connection), mysql_error(connection));
	}

	//Вывод данных
	MYSQL_RES *res_ptr;
	MYSQL_ROW sqlrow;
	unsigned int field_count;
	res = mysql_query(connection, "SELECT name FROM test");
	if(res){
		printf("Select error: %s\n", mysql_error(connection));
	}
	else{
		res_ptr = mysql_use_result(connection);
		if(res_ptr){
			while((sqlrow = mysql_fetch_row(res_ptr))){
				field_count = 0;
				while(field_count < mysql_field_count(connection)){
					printf("%s \n", sqlrow[field_count]);
					field_count++;
				}
			}
			mysql_free_result(res_ptr);
		}
	}

	//Закрытие дескриптора
	mysql_close(connection);

	return EXIT_SUCCESS;
}

